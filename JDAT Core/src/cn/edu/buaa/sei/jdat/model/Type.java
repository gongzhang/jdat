package cn.edu.buaa.sei.jdat.model;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import cn.edu.buaa.sei.jdat.Utility;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Jar Dependency Analysis Toolkit
//  @ File Name : Type.java
//  @ Date : 2012/1/13
//  @ Author : 
//
//

public abstract class Type extends DependentNode<Type> implements Element, IModifier {
	
	private String name;
	private String cachedSignature = null;
	
	private Package owner;
	private List<Member> members;
	
	protected Set<Type> supertypes;
	protected Set<Type> subtypes;
	
	private Set<String> supertypeNames;
	private Set<String> referenceNames;
	
	private boolean isAbstract = false;
	private boolean isStatic = false;
	private boolean isFinal = false;
	private int accessModifier = IModifier.UKNOWN;
	
	public Type() {
		this.references = new HashSet<Type>();
		this.inverseReferences = new HashSet<Type>();
		this.members = new ArrayList<Member>();
		
		this.supertypes = new HashSet<Type>(1, 0.9f);
		this.subtypes = new HashSet<Type>(1);
		
		this.supertypeNames = new HashSet<String>(1, 0.9f);
		this.referenceNames = new HashSet<String>(1);
	}
	
	public boolean isUnknown() {
		return this.members == null;
	}
	
	public void addSupertypeName(String name) {
		this.supertypeNames.add(name);
	}
	
	@Deprecated
	public void removeSupertypeName(String name) {
		this.supertypeNames.remove(name);
	}
	
	/**
	 * Add Unresolved reference name.
	 * @param name
	 */
	public void addUnresolvedReferenceName(String name) {
		if (name.equals(this.getSignature()))
			return;
		this.referenceNames.add(name);
	}
	
	@Deprecated
	public void removeUnresolvedReferenceName(String name) {
		this.referenceNames.remove(name);
	}
	
	public void addSubtype(Type type) {
		this.subtypes.add(type);
	}
	
	public void removeSubtype(Type type) {
		this.subtypes.remove(type);
	}
	
	public boolean isSubtypeOf(String name) {
		return this.supertypeNames.contains(name);
	}
	
	public boolean isSubtypeOf(Type type) {
		return this.supertypes.contains(type);
	}
	
	public String[] getUnresolvedSupertypes() {
		return this.supertypeNames.toArray(new String[0]);
	}
	
	public String[] getUnresolvedReferences() {
		return this.referenceNames.toArray(new String[0]);
	}
	
	Type(String signature) {
		this.setName(signature);
	}
	
	public static Type createUnknownType(String signature) {
		return new Type(signature){
			@Override
			public String getName() {
				return Utility.getTypeName(this.getSignature());
			}
			
			@Override
			public String getSignature() {
				return ((Type)this).name;
			}
			
			@Override
			public String getSimpleSignature() {
				return ((Type)this).name;
			}
		};
	}
	
	public boolean isResolved() {
		return true;
	}
	
	public Package getOwner() {
		return this.owner;
	}
	
	public void setOwner(Package owner) {
		this.owner = owner;
	}
	
	public void addMember(Member m) {
		members.add(m);
	}
	
	public List<Member> getMembers() {
		return this.members;
	}
	
	@Override
	public String getName() {
		return name;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	@Override
	public String getSignature() {
		// this function is performance bottleneck. need cache
		if (this.owner == null || this.name == null)
			throw new IllegalStateException("Incomplete Type");
		if (cachedSignature == null) {
			StringBuilder buf = new StringBuilder(this.owner.getSignature());
			buf.append('.');
			buf.append(this.name);
			cachedSignature = buf.toString();
		}
		return cachedSignature;
	}
	
	@Override
	public String getSimpleSignature() {
		if (this.owner == null)
			return this.name;
		return this.owner.getSignature() + "." + this.name;
	}
	
	@Override
	public String toString() {
		return "T" + this.getSignature();
	}

	@Override
	public void addReference(Type node) {
		String signature = node.getSignature();
		if (this.referenceNames.contains(signature)) {
			this.references.add(node);
			// Update the raw references strings.
			this.referenceNames.remove(signature);
			if (this.supertypeNames.contains(signature)) {
				this.supertypes.add(node);
				// Update the raw references strings.
				this.supertypeNames.remove(signature);
			}
		}
	}
	
	@Override
	public void removeReference(Type node) {
		String signature = node.getSignature();
		if (this.references.contains(node)) {
			// Update the raw references strings.
			this.referenceNames.add(signature);
			this.references.remove(node);
			if (this.supertypes.contains(node)) {
				// Update the raw references strings.
				this.supertypeNames.add(signature);
				this.supertypes.remove(node);
			}
		}
	}
	
	/**
	 * This method should be called before unresolved-table and resolved-table updated.
	 */
	@Override
	public void addInverseReference(Type node) {
		this.inverseReferences.add(node);
		if (node.isSubtypeOf(this.getSignature()) | node.isSubtypeOf(this)) {
			this.subtypes.add(node);
		}
	}
	
	@Override
	public void removeInverseReference(Type node) {
		this.inverseReferences.remove(node);
		if (this.subtypes.contains(node)) {
			subtypes.remove(node);
		}
	}
	
	@Override
	public boolean isAbstract() {
		return isAbstract;
	}
	
	public void setAbstract(boolean isAbstract) {
		this.isAbstract = isAbstract;
	}
	
	@Override
	public boolean isFinal() {
		return isFinal;
	}
	
	public void setFinal(boolean isFinal) {
		this.isFinal = isFinal;
	}
	
	@Override
	public boolean isStatic() {
		return isStatic;
	}
	
	public void setStatic(boolean isStatic) {
		this.isStatic = isStatic;
	}
	
	@Override
	public int getAccessModifiers() {
		return accessModifier;
	}
	
	public void setAccessModifiers(int m) {
		this.accessModifier = m;
	}
	
	public void destory() {
		members.clear();
		members = null;
		supertypes.clear();
		supertypes = null;
		subtypes.clear();
		subtypes = null;
		supertypeNames.clear();
		supertypeNames = null;
		referenceNames.clear();
		referenceNames = null;
	}
	
}
